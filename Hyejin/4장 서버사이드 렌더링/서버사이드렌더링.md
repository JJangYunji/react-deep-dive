# 4장 서버 사이드 렌더링

## 4.1 서버사이드 렌더링이란?

> 싱글페이지 애플리케이션

- 렌더링과 라우팅에 필요한 대부분의 기능을 서버가 아닌 브라우저의 자바스크립트에 의존하는 방식
- 최초 첫 페이지에서 데이터를 모두 불러온 이후 서버에서 html을 내려받지 않고 하나의 페이지에서 모든 작업을 처리한다.
  - 개발자 도구 > htmld 코드 내 body에 아무 내용이 없음  
    ( 렌더링에 필요한 body 내부의 내용을 모두 자바스크립트 코드로 삽입한 이후에 렌더링 하기 때문)
  - 페이지 전환 시에도 html을 새로 요청하는게 아닌 자바스크립트에서 다음 페이지 렌더링에 필요한 정보만 http 요청등으로 가져온 다음 body내부에 dom을 추가, 수정, 삭제 하는 방법으로 페이지가 전환된다.

> 서버사이드 렌더링

- 웹페이지가 점점 느려지는 상황에 대한 문제의식을 SPA의 태생적인 한계에서 찾고, 이를 개선하고자 서버에서 페이지를 렌더링해 제공하는 기존 방식의 웹 개발이 다시금 떠오르고 있다.
- 클라이언트의 렌더링은 사용자 기기 성능에 영향을 받지만, 서버 사이드 렌더링은 서버에서 제공하기 때문에 비교적 안정적인 렌더링이 가능하다.

**서버 사이드 렌더링의 장점**

- 최초 페이지 진입이 빠르다
- 검색 엔진과 SNS 공유 등 메타데이터 제공이 쉽다
- 누적 레이아웃 이동이 적다
  CLS(Cumulative Layout Shift), 즉 누적 레이아웃 이동을 줄일 수 있습니다. 클라이언트에서 API 호출이 제각각일 수 있고 그런 환경 때문에 레이아웃 이동이 있을 수 있어 사용자 경험에 좋지 않은 영향을 주게 됩니다.
- 사용자의 디바이스 성능에 비교적 자유롭다
  자바스크립트 리소스 실행은 사용자의 디바이스에서만 실행되므로 사용자 디바이스 성능에 의존적 하지만 SSR에서는 서버와 이 부담을 나눠서 수행하기 때문에 상대적으로 자유로울 수 있다.
- 보안에 좀 더 안전하다
  API 호출이나 민감 정보 등 모든 것을 클라이언트에서 노출된 채로 처리되되는데, SSR에서는 상대적으로 보안 위협을 피할 수 있다는 장점이 있다.

**서버 사이드 렌더링의 단점**

- 소스코를 작성할 떄 항상 서버를 고려해야한다.  
  브라우저에만 있는 전역객체의 경우 서버에서 실행된다면 undefined 에러가난다.
- 적절한 서버가 구축돼 있어야 한다.  
  서버 내부에서 렌더링을 수행하고 요청 분산, 복구 전략 등 서버 구축과 서버 관리에 대한 부담
- 서비스 지연에 따른 문제  
  로딩과 같은 서비스 지연에 따른 별도의 안내나 UI 요소를 제공하기가 CSR에 비해 수월하지 않은 부분이 있습니다.

**현대의 서버 사이드 렌더링**  
최근 서버사이드 렌더링은 기존의 LAMP 스택에서 표현했던것과는 다르다.  
최초 웹사이트 진입 시에는 서버사이드 렌더링으로 서버에서 완성된 html을 받고, 이후 라우팅에서는 서버에서 내려받은 자바스크립트를 바탕으로 싱글페이지 애플리케이션 처럼 작동한다.

## 4.2 서버 사이드 렌더링을 위한 리액트 api

- renderTostring
  - 인수로 넘겨받은 리액트 컴포넌트를 렌더링해 HTML 문자열로 반환하는 함수, 최초의 페이지를 HTML로 먼저 렌더링할 때 그 역할을 하는 함수
  - div#root에 생성된 data-reactroot는 리액트 컴포넌트의 루트 엘리먼트가 무엇인지 식별하는 역할로 추후 hydrate 함수에서 루트를 식별하는 기준이 된다.
- renderToStaticMarkup
  - renderToString과 거의 유사하지만 hydrate할 수 있는 식별하는 기준이 없으므로, data-reactroot와 같은 리액트에서 사용되는 추가적인 DOM 속성을 만들지 않은 순수 HTML 문자열이 반환된다.
- renderToNodoStream
  - renderToString과 결과물은 완전히 동일하지만, 이 함수는 완전히 Node.js 환경에 의존하고 있어 브라우저에서 실행이 불가능
  - renderToNodeStream의 결과물은 Node.js의 ReadableStream
  - SSR 프레임워크는 모두 renderToString 대신 renderToNodeStream을 채택  
    (HTML의 크기가 큰 경우 청크 단위로 쪼개 연속적으로 작성하게 되면 리액트 애플리케이션을 렌더링하는 Node.js 서버의 부담을 덜 수 있다.)
- renderToStaticNodoStream
  - renderToStaticMarkup과 마찬가지로 제공하는 결과물은 동일하지만, 리액트 자바스크립트에 필요한 리액트 속성이 제공되지 않아 hydrate 할 필요가 없는 순수 html 결과물이 필요할 때 사용한다.
- hydrate
  - renderToString과 renderToNodeStream으로 생성된 HTML 콘텐츠에 자바스크립트 핸들러나 이벤트를 붙이는 역할(사용자 인터랙션)
  - 별도의 인수로 html 요소를 넘겨서 해당 컴포넌트의 렌더링과 이벤트 핸들러를 붙이는 작업까지 한 번에 수행하는 클라이언트의 render와는 다르게 이미 렌더링된 html이 있다는 가정하에 작업이 수행되고 렌더링된 html을 기준으로 이벤트를 붙이는 작업만 실행한다.

## 4.3 Next js

- 리액트 서버사이드 렌더링 프레임워크
- 서버 사이드 렌더링(SSR), 정적 사이트 생성(Static Site Generation, SSG), 클라이언트 사이드 렌더링(Client-Side Rendering, CSR)을 지원

**파일 기반 라우팅**

- Next.js의 라우팅은 pages 디렉토리 내의 파일 구조를 기반
- 각 파일은 라우트 경로에 대응되며, 파일 이름이 URL 경로로 사용된다.
  ex) pages/about.js는 /about으로 접근할 수 있는 라우트를 생성한다.

- 동적 라우팅: [param].js와 같은 형식을 사용해 동적 라우트를 생성
  - pages/posts/[id].js는 /posts/1, /posts/2 등의 경로로 접근할 때 해당 페이지로 라우팅
- 중첩 라우팅: 디렉토리 구조를 사용하여 중첩 라우트를 구성
  - ex) pages/posts/edit/index.js 파일은 /posts/edit 경로에 대응된다.

**프로그래매틱 라우팅**
useRouter 훅 또는 next/link와 next/router 컴포넌트를 통해 프로그래밍 방식으로 라우팅을 제어할 수 있다.

- next/link: 사용자가 새 페이지로 이동할 수 있게 해주는 컴포넌트
  `<Link href="/about"><a>About Us</a></Link>`와 같이 사용한다.
- next/router: 라우터 객체를 통해 라우트를 조작한다.
  - router.push('/about')를 호출하여 /about 페이지로 이동한다.
- useRouter 훅: 함수 컴포넌트 내에서 라우터 객체에 접근할 수 있게 해주는 훅입니다. 이를 통해 현재 라우트의 정보를 얻거나 라우트를 변경할 수 있습니다.

**특수 페이지**

- \_app.js: 모든 페이지에 공통으로 적용될 최상위 컴포넌트를 정의
- \_document.js: 서버 사이드에서만 렌더링되며, 초기 문서 마크업을 구성하는 데 사용된다. HTML, Head, Body 태그를 커스터마이즈할 수 있다.

**서버 사이드 렌더링(SSR)을 위한 함수**

- getServerSideProps(context)
  - 페이지가 요청받을 때마다 서버에서 실행
  - 페이지 렌더링에 필요한 데이터를 서버에서 미리 가져와서 페이지 컴포넌트로 props를 통해 전달한다.
  - 동적 라우팅과 함께 사용될 수 있으며, context 파라미터를 통해 동적 경로 값 등을 알 수 있다.

**정적 사이트 생성(SSG)을 위한 함수**

- getStaticProps(context)
  - 빌드 시에 데이터를 가져와서 정적 파일로 생성
  - 페이지의 props로 데이터를 전달하며, 이 함수가 사용된 페이지는 정적으로 생성되어 배포된다.
  - 동적 라우팅 페이지에 사용될 경우, getStaticPaths와 함께 사용되어야 한다.
- getStaticPaths()
  - 동적 라우트를 가진 페이지에서 SSG를 사용할 경우, 어떤 경로들이 정적으로 생성될 것인지 정의
  - getStaticProps와 함께 사용되며, 빌드 시에 생성할 경로들의 목록을 반환한다.
  - `{ paths: [], fallback: false }` 형태로 반환하며, paths는 생성할 경로들, fallback은 정의되지 않은 경로에 접근했을 때의 처리 방식을 정의한다.  
    fallback이 true이면 미리 빌드하지 않은 페이지에 접근할 경우 빌드되기 전까지 fallback 컴포넌트를 보여준다.

**클라이언트 사이드 렌더링(CSR)을 위한 함수**
Next.js에서 CSR을 구현하기 위한 특정 함수는 제공되지 않지만, React의 상태 관리와 효과(Hooks)를 사용하여 구현할 수 있습니다. 페이지 컴포넌트 내부에서 데이터를 가져오고 상태를 관리하기 위해 useEffect와 useState를 사용할 수 있습니다.

**추가적인 렌더링 최적화 함수**

- getInitialProps(context)
  - SSR과 SSG에서 사용할 수 있다.
  - 페이지나 \_app.js에서 사용할 수 있으며, 페이지 렌더링에 필요한 초기 props를 가져오는 데 사용된다.
  - getServerSideProps나 getStaticProps와는 다르게, 모든 페이지 방문 시마다 실행될 수 있어, 사용 시 성능에 영향을 줄 수 있다.
