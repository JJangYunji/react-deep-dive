# 04장: 서버 사이드 렌더링

## 4.1 서버 사이드 렌더링이란?

### 4.1.1 싱글 페이지 애플리케이션의 세상

#### 싱글 페이지 애플리케이션(Single Page Application: SPA)

- 렌더링과 라우팅에 필요한 대부분의 기능을 서버가 아닌 브라우저의 자바스크립트에 의존하는 방식입니다.
- 초기에 애플리케이션의 전체 또는 필요한 구성요소를 한 번에 로드하여 사용자의 브라우저에 저장합니다.
- 페이지를 불러온 이후에는 서버에서 HTML를 내려받지 않고 하나의 페이지에서 모든 작업을 처리합니다.
- 사용자가 애플리케이션 내에서 다양한 작업을 수행할 때, 전체 페이지를 다시 로드하는 대신 필요한 데이터만을 동적으로 불러와 업데이트합니다.
- 결과적으로 페이지 간 전환은 더 빠르고 부드럽게 이루어지며, 서버 요청의 수도 줄어들어 성능이 향상됩니다.

#### 전통적인 웹 애플리케이션

- 사용자가 웹 페이지의 링크를 클릭할 때마다 서버로부터 전체 페이지를 새로 로드해야 합니다.
- 이 과정에서 페이지의 레이아웃, 스타일, 스크립트 등 모든 리소스가 다시 다운로드될 수 있으며, 이는 네트워크 지연으로 인해 사용자 경험이 저하될 수 있습니다.
- 서버 측에서는 각 요청마다 새로운 페이지를 생성하여 전달하는 방식으로 작동합니다.

### 4.1.2 서버 사이드 렌더링이란?

#### 서버 사이드 렌더링(Server Side Rendering: SSR)

- 최초에 사용자에게 보여줄 페이지를 서버에서 렌더링해 빠르게 사용자에게 화면을 제공하는 방식입니다.
- 싱글 페이지 애플리케이션과 서버 사이드 렌더링의 차이는 웹페이지 렌더링의 책임을 어디에 두느냐 입니다.
    - 싱글 페이지 애플리케이션: 사용자에게 제공되는 자바스크립트 번들에게 렌더링을 담당
    - 서버 사이드 렌더링: 렌더링에 필요한 작업을 모두 서버에서 수행
- 클라이언트의 렌더링은 사용지 기기의 성능에 영향을 받지만 서버 사이드 렌더링은 서버에서 제공하기 때문에 비교적 안정적인 렌더링이 가능합니다.

#### 서버 사이드 렌더링의 장점

1. 최초 페이지의 진입이 비교적 빠르다.
    - 페이지에 유의미한 정보가 그려지는 시간(First Contentful Paint)이 더 빨라질 수 있습니다.
    - 서버에서 모든 HTML을 렌더링하고 사용자는 서버로부터 완성된 페이지를 받게 되므로, 클라이언트 측에서 HTML을 구성하는데 필요한 자바스크립트를 로드하고 실행하는 시간이 절약됩니다.
2. 검색 엔진과 SNS 공유 등 메타데이터 제공이 쉽다.
    - 검색 엔진 최적화(Search Engine Optimization: SEO)에 유용합니다.
    - 서버에서 미리 페이지의 모든 콘텐츠를 렌더링할 때, 검색 엔진이 페이지의 콘텐츠를 쉽게 크롤링하고 인덱싱할 수 있도록 도와줍니다.
    - 각 페이지의 메타데이터(예: 제목, 설명, 소셜 미디어 공유용 이미지 등)도 함께 서버에서 생성되어 전송되기 때문에, 소셜 미디어 공유 시 해당 페이지의 정보가 정확히 표시될 수 있습니다.
3. 누적 레이아웃 이동이 적다.
    - 누적 레이아웃 이동: 사용자에게 페이지를 보여준 이후에 뒤늦게 어떤 HTML 정보가 추가되거나 삭제되어 마치 화면이 덜컥거리는 것과 같은 부정적인 사용자 경험을 의미합니다.
    - 서버에서 페이지를 미리 렌더링하고 전송하기 때문에, 클라이언트 측에서 큰 레이아웃 변화 없이 콘텐츠를 표시할 수 있습니다.
4. 사용자의 디바이스 성능에 비교적 자유롭다.
    - 페이지의 렌더링이 서버에서 이루어지기 때문에, 사용자의 디바이스 성능에 영향을 덜 받습니다.
    - 클라이언트 측에서 많은 자바스크립트를 처리하는 것에 비해, 서버 사이드에서 처리하고 완성된 페이지를 전송하는 것이 특히 성능이 낮은 디바이스에서의 웹 경험을 향상시킬 수 있습니다.
5. 보안에 좀 더 안전하다.
    - 인증 혹은 민감한 작업을 서버에서 수행하고 그 결과만 브라우저에 제공해 이러한 보안 위협을 피할 수 있습니다.
    - 필수적인 로직과 데이터 처리가 서버 측에서 이루어지므로, 클라이언트(브라우저)에 전송되는 코드 양이 줄어듭니다. 이는 공격자가 클라이언트 측 코드를 분석하여 보안 취약점을 찾아내는 것을 더 어렵게 만듭니다.

#### 서버 사이드 렌더링의 단점

1. 소스코드를 작성할 때 항상 서버를 고려해야 한다.
    - 소스코드 전반에 절쳐 서버 환경에 대한 고려가 필요합니다.
    - 클라이언트 측에서만 실행되는 코드와 서버 측에서 렌더링되어야 하는 코드를 구분하고 관리해야 합니다.
        - `window`에 대한 접근을 최소화해야 하고, `window` 사용이 불가피하다면 해당 코드가 서버 사이드에서 실행되지 않도록 처리해야 합니다.
2. 적절한 서버가 구축돼 있어야 한다.
    - 사용자의 요청을 받아 렌더링을 수행할 서버가 필요합니다.
    - 모든 페이지 요청마다 서버에서 페이지를 렌더링하고 사용자에게 전송해야 하므로, 동시에 많은 요청을 처리할 수 있는 충분한 서버 자원과 성능이 요구됩니다.
3. 서비스 지연에 따른 문제.
    - 네트워크 지연, 서버 처리 시간, 서버의 부하 상태 등 여러 요인에 따라 페이지 로딩 시간이 증가할 수 있습니다.
    - 지연 작업이 최초 렌더링에 발생한다면, 서버에서 사용자에게 보여줄 페이지에 대한 렌더링 작업이 끝나기까지는 사용자에게 그 어떤 정보도 제공할 수 없게 됩니다.

### 4.1.3 SPA와 SRS를 모두 알아야 하는 이유

- 서버 사이드 렌더링 역시 만능은 아닙니다.
- 웹페이지에서 사용자에게 제공하고 싶은 내용이 무엇인지, 또 어떤 우선순위에 따라 페이지의 내용을 보여줄지를 잘 설계하는 것이 중요합니다.

#### SPA와 SSR의 장단점을 고려하여 선택

- SPA 선택 시 고려 사항
    - 사용자와의 상호작용이 매우 빈번한 경우
    - 복잡한 사용자 인터페이스와 애니메이션이 필요한 경우
- SSR 선택 시 고려 사항
    - 초기 페이지 로딩 속도가 중요한 경우
    - 콘텐츠의 검색 엔진 최적화가 중요한 경우

#### 현대의 서버 사이드 렌더링

- 요즘의 서버 사이드 렌더링은 SPA, SSR 두가지 장점을 모두 취한 방식으로 작동합니다.
- 최초 웹사이트 진입 시에는 SSR 방식으로 서버에서 완성된 HTML을 제공받고, 이후 라우팅에서는 서버에서 내려받은 자바스크립트를 바탕으로 마치 SPA처럼 작동합니다.
- Next.js, Remix 등의 프레임워크는 이러한 방식을 지원하며, 이를 통해 SPA와 SSR의 장점을 모두 취할 수 있습니다.

## 4.2 서버 사이드 렌더링을 위한 리액트 API 살펴보기

- 리액트는 리액트 애플리케이션을 서버에서 렌더링할 수 있는 API를 제공합니다.
- API는 브라우저의 window 환경이 아닌 Node.js와 같은 서버 환경에서만 실행할 수 있습니다.

### 4.2.1 renderToString

- `renderToString` 함수는 리액트 요소를 초기 HTML 문자열로 렌더링합니다.
- 이 함수는 서버에서 리액트 애플리케이션을 렌더링하고, 그 결과를 문자열 형태로 반환하여 클라이언트로 전송하는 데 사용됩니다.
- 이 과정을 통해 클라이언트 측에서 JavaScript가 로드되기 전에도 사용자에게 페이지를 보여줄 수 있으며, SEO 최적화에도 유리합니다.

### 4.2.2 renderToStaticMarkup

- `renderToStaticMarkup` 함수도 리액트 요소를 HTML 문자열로 렌더링하지만, `renderToString`과 달리 리액트 내부 데이터 속성(`data-리액트root` 등)을 포함하지 않습니다.
- 이 함수는 완전히 정적인 페이지를 생성할 때 사용되며, 클라이언트 사이드에서의 리액트 애플리케이션 재활성화 없이 순수한 HTML만 필요한 경우에 적합합니다.

#### renderToString vs renderToStaticMarkup

- 공통점
    - 두 함수 모두 리액트 컴포넌트를 HTML 문자열로 변환합니다.
- 차이점
    - `renderToString`은 리액트 데이터 속성을 포함하여 클라이언트 사이드에서 애플리케이션을 활성화할 수 있도록 합니다.
    - `renderToStaticMarkup`은 데이터 속성 없이 순수한 HTML만을 생성하므로, 리액트 애플리케이션을 다시 활성화할 수 없습니다.
    - `renderToString`은 동적인 페이지에, `renderToStaticMarkup`은 완전히 정적인 페이지에 적합합니다.

### 4.2.3 renderToNodeStream

- `renderToNodeStream` 함수는 리액트 요소를 Node.js 스트림을 통해 HTML 문자열로 변환합니다.
- 이 함수는 `renderToString`보다 메모리 사용량을 줄이고, 대용량 HTML을 생성할 때 더 효율적인 성능을 제공합니다.
- 초기 HTML이 사용자에게 조금 더 빨리 전송되기 시작하여, 특히 대규모 애플리케이션에서 로딩 시간을 단축시킬 수 있습니다.

### 4.2.4 renderToStaticNodeStream

- `renderToStaticNodeStream` 함수는 `renderToNodeStream`과 유사하게 작동하지만, `renderToStaticMarkup`처럼 리액트 내부 데이터 속성을 포함하지 않는 정적인 HTML을 스트림을 통해 생성합니다.
- 이 함수는 대규모 정적 페이지를 효율적으로 서버 사이드에서 렌더링하고 싶을 때 사용됩니다.

#### renderToNodeStream vs renderToStaticNodeStream

- 공통점
    - 두 함수 모두 리액트 컴포넌트를 Node.js 스트림을 통해 HTML로 변환합니다.
    - 대용량 데이터 처리에 유리하며, 메모리 사용량을 줄이고 성능을 개선합니다.
- 차이점
    - `renderToNodeStream`은 `renderToString`과 마찬가지로 리액트 데이터 속성을 포함합니다.
    - `renderToStaticNodeStream`은 `renderToStaticMarkup`과 같이 순수한 HTML만 생성합니다.
    - `renderToNodeStream`는 동적인 페이지를 위한 스트리밍, `renderToStaticNodeStream`는 정적인 페이지를 위한 스트리밍에 적합합니다.

### 4.2.5 hydrate

- `hydrate` 함수는 서버 사이드 렌더링으로 생성된 HTML에 리액트 이벤트 핸들러를 붙이는 과정을 담당합니다.
- 이 함수는 서버에서 렌더링된 마크업과 동일한 리액트 컴포넌트를 클라이언트에서 재사용하여, 애플리케이션을 대화형으로 만듭니다.
- `hydrate`는 기본적으로 `renderToString` 또는 `renderToNodeStream`과 함께 사용되며, SSR 애플리케이션의 초기 로딩 성능을 개선하고 사용자 경험을 향상시키는 데 중요한 역할을 합니다.
