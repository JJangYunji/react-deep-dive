# 10장: 리액트 17과 18의 변경 사항 살펴보기

- 리액트가 제공하는 최신 기능을 모두 활용하려면 리액트가 제공하는 새로운 버전을 조금씩 따라잡을 필요가 있다
- 리액트에 의존적인 라이브러리를 사용한다면 `peerDependencies`를 통해 리액트에 의존하고 있으므로 버전 업을 위해서는 이 라이브러리가 지원하는 버전에 대해 꼼꼼하게 살펴봐야 한다
    - 최소 리액트 지원 버전을 올렸는데, 사용 중인 서비스에서 아직 구형 버전의 리액트를 사용하고 있다면 낭패를 볼 수 있다

## 10.1 리액트 17 버전 살펴보기

### 10.1.1 리액트의 점진적인 업그레이드

- 리액트 17 버전은 16 버전과 다르게 새롭게 추가된 기능이 없으며 호환성이 깨지는 변경 사항, 즉 기존에 사용하던 코드의 수정을 필요로 하는 변경 사항을 최소화했다
- 기존에는 새로운 주 버전이 릴리스되면 이전 버전에서의 API 제공을 완전히 중단해 버리고, 전체 애플리케이션을 새롭게 업그레이드하기를 요구하고 있었다
    - 리액트 17 버전부터는 점진적인 업그레이드가 가능해진다
    - 전체 애플리케이션 트리는 리액트 17이지만 일부 트리와 컴포넌트에 대해서만 리액트 18을 선택하는 점진적인 버전 업이 가능해진다

### 10.1.2 이벤트 위임 방식의 변경

- 이벤트 단계
    - 캡처(capture): 이벤트 핸들러가 트리 최상단 요소에서 부터 시작해서 실제 이벤트가 발생한 타깃 요소까지 내려간다
    - 타깃(target): 이벤트 핸들러가 타깃 노드에 도달한다. 이때 이벤트가 호출된다
    - 버블링(bubbling): 이벤트가 발생한 요소에서부터 시작해 최상위 요소까지 다시 올라간다
- 이벤트 위임(event delegation)
    - 이벤트를 처리하는 방식 중 하나로, 이벤트를 처리할 때 이벤트를 발생시킨 요소에 직접 이벤트 핸들러를 등록하는 것이 아니라 상위 요소에 이벤트 핸들러를 등록하고, 이벤트가 발생한 요소를 찾아내는 방식
    - 하위 요소에서 발생한 이벤트를 상위 요소에 등록된 이벤트 핸들러를 통해 처리한다
    - 리액트는 이벤트 핸들러를 각 요소가 아닌 document에 연결해서 이벤트를 좀 더 효율적으로 관리한다
- 리액트 17 버전에서는 이벤트 위임 방식이 변경되었다
    - 리액트 16 버전까지는 이벤트 핸들러를 `document`에 연결해 이벤트를 관리했다
    - 리액트 17 버전부터는 이벤트 핸들러를 리액트 컴포넌트 최상단 트리, 즉 루트 요소로 변경되었다
        - 서로 다른 리액트 버전에서 발생할 수 있는 문제를 해결하기 위해 이벤트 위임의 대상을 `document`에서 컴포넌트의 최상위로 변경되었다
        - 각 이벤트는 해당 리액트 컴포넌트 트리 수준으로 격리되므로 이벤트 버블링으로 인한 혼선을 방지할 수 있다

### 10.1.3 import React from 'react'가 더이상 필요 없다: 새로운 transform

- JSX는 브라우저가 이해할 수 있는 코드가 아니므로 바벨이나 타입스크립트를 활용해 JSX를 실행하기 위해 일반적인 자바스크립트로 변환하는 과정이 꼭 필요하다
- 리액트 16 버전까지는 JSX 변환을 사용하기 위해 코드내에서 `React`를 사용하는 구문이 없더라도 `import React from 'react'`가 필요했고, 이 코드가 없으면 에러가 발생했다
- 리액트 17 버전부터는 바벨과 협력해 이러한 import 구문 없이도 JSX를 변환할 수 있게 되었다
    - `React.createElement`가 사라졌다
    - JSX를 변환할 때 필요한 모듈인 `react/jsx-runtime`을 불러오는 require 구문이 추가된다
    - `import React` 구문을 삭제함으로써 번들 크기를 줄일 수 있다

### 10.1.4 그 밖의 주요 변경 사항

#### 1) 이벤트 풀링 제거

- 이벤트 풀링
    - 이벤트 객체를 재사용하여 메모리 사용을 최소화하고 성능을 향상시키는 기법
    - `SyntheticEvent` 객체를 사용해 이벤트를 처리하고, 이벤트가 끝나면 해당 객체를 초기화해 재사용하는 방식
        - `SyntheticEvent` 이벤트: 브라우저의 기본 이벤트를 한 번 더 감싼 이벤트 객체
    - 풀에서 이벤트를 받아오고, 이벤트가 종료되자마자 다시 초기화하는(`null`로 변경하는) 방식
- 리액트 16 버전까지는 이벤트 풀링 방식을 통해 서로 다른 이벤트 간에 이벤트 객체를 재사용한다
    - 비동기 코드 내에서 이벤트 객체를 참조하면 이벤트 객체가 이미 초기화된 이후이기 때문에 버그가 발생할 수 있다
    - 비동기적으로 이벤트 객체를 사용하고자 할 때는 `e.persist()`를 호출해야 한다
- 리액트 17 버전부터는 이벤트 풀링 개념이 삭제된다
    - 이벤트 핸들러 내부에서 이벤트 객체에 접근할 때 비동기든 동기든 상관없이 일관적으로 동작한다

#### 2) useEffect 클린업 함수의 비동기 실행

- 클린업 함수: 컴포넌트가 언마운트되거나 업데이트되기 직전에 실행되는 함수
- 리액트 16 버전까지는 `useEffect` 훅의 클린업 함수가 동기적으로 실행되었다
- 리액트 17 버전부터는 화면이 완전히 업데이트된 이후에 클린업 함수가 비동기적으로 실행된다
    - 리렌더링이 일어난 뒤에 실행되어 화면에 업데이트가 반영되는 시간(commitTime)이 빨라진다

#### 3) 컴포넌트의 undefined 반환에 대한 일관적인 처리

- 리액트 16, 17 버전 모두 컴포넌트 내부에서 `undefind`를 반환하면 오류가 발생한다
- 리엑트 16 버전에서는 `forwardRef`나, `memo`와 같은 고차 컴포넌트를 사용할 때 `undefined`를 반환하면 오류가 발생하지 않는다
- 리액트 17 버전에서는 `undefined`를 반환하면 오류가 정상적으로 발생한다
- 리액트 18 버전부터는 `undefined`를 반환해도 오류가 발생하지 않는다

## 10.2 리액트 18 버전 살펴보기

- 리액트 18 버전에서는 다양한 기능들이 추가되었다
    - 가장 큰 변경점은 동시성 지원이다

### 10.2.1 새로 추가된 훅 살펴보기

- 리액트 18 버전에서는 새로운 훅이 추가되었다

#### 1) useId

- 고유한 식별자를 생성할 때 사용하는 훅
- 클라이언트와 서버에서 불일치를 피하면서 컴포넌트 내부의 고유한 값을 생성할 수 있다
    - 같은 컴포넌트임에도 서로 인스턴스가 다르면 다른 랜덤하고 유니크한 값을 만들어낸다
    - 서버 사이드와 클라이언트 간에 동일한 값이 생성되어 하이드레이션 이슈도 발생하지 않는다

#### 2) useTransition

- UI 변경을 가로막지 않고 상태를 업데이트할 수 있는 훅
- 무거운 렌더링 작업을 지연시킬 수 있다
    - 상태 변경으로 인해 무거운 작업이 발생하고, 이로 인해 렌더링이 가로막힐 여지가 있는 경우 사용 가능
- 동시성을 지원한다
    - 느린 렌더링 과정에서 로딩 화면을 보여줄 수 있다
    - 지금 진행 중인 렌더링을 버리고 새로운 상태값으로 다시 렌더링할 수 있다

#### 3) useDeferredValue

- 리렌더링이 급하지 않은 부분을 지연할 수 있게 도와주는 훅
- 고정된 지연 시간 없이 첫 번째 렌더링이 완료된 이후에 `userDeferredValue`로 지연된 렌더링을 수행한다
- `useTransition`처럼 렌더링을 지연시킬 수 있다
    - `useTransition`
        - state 값을 업데이트하는 함수를 감싸서 사용한다
        - 낮은 우선순위로 처리해야 할 작업에 대해 직접적으로 상태를 업데이트할 수 있는 코드에 접근하는 경우 사용
    - `useDeferredValue`
        - state 값 자체만을 감싸서 사용한다
        - 상태 업데이트에 관여할 수는 없고 오로지 값만 받아야 하는 경우 사용

#### 4) useSyncExternalStore

- 외부 스토어와 리액트 상태를 동기화하는 훅
- 테어링(tearing) 현상을 방지한다
    - 테어링: 하나의 state 값이 있음에도 서로 다른 값을 기준으로 렌더링되는 현상
    - 외부 데이터(서버에서 가져온 데이터)와 리액트 상태가 동기화되지 않아 발생하는 문제
- 외부에 상태가 있는 데이터에는 반드시 `useSyncExternalStore`를 사용해 값을 가져와야 `startTransition` 등으로 인한 테어링 현상이 발생하지 않는다

#### 5) useInsertionEffect

- CSS-in-JS 라이브러리와 같이 스타일을 조작할 때 사용하는 훅
- `useEffect`와 비슷하지만, DOM 업데이트 전에 호출되는 점이 다르다
    - 브라우저가 다시금 스타일을 입혀서 DOM을 재계산하지 않아도 된다
- DOM 업데이트 전에 호출되므로, 렌더링과 화면 업데이트 사이의 잠재적인 깜박임을 방지하는 데 유용하다

### 10.2.2 react-dom/client

- createRoot
    - 기존의 react-dom에 있던 `render` 메서드를 대체할 새로운 메서드
    - 리액트 18 버전을 사용하고 싶다면 `createRoot`와 `render`를 함께 사용해야 한다
- hydrateRoot
- 서버 사이드 렌더링 애플리케이션에서 하이드레이션을 하기 위한 새로운 메서드

### 10.2.3 react-dom/server

- renderToPipeableStream
    - 리액트 컴포넌트를 HTML로 렌더링하는 메서드
    - HTML을 점진적으로 렌더링하고 클라이언트에서는 중간에 script를 삽입하는 등의 작업을 할 수 있다
- renderToReadableStream
    - 웹 스트림을 사용하는 모던 엣지 런타임 환경에서 사용되는 메서드

### 10.2.4 자동 배치(Automatic Batching)

- 자동 배치: 리액트가 여러 상태 업데이트를 하나의 리렌더링으로 묶어서 성능을 향상시키는 방법
- 리액트 17 버전까지는 이벤트 핸들러 내부에서는 자동 배치 작업이 이뤄지고 있었지만, `Promise`, `setTimeOut` 같은 비동기 이벤트에서는 자동 배치가 이뤄지고 있지 않았다
- 리액트 18 버전부터는 루트 컴포넌트를 `createRoot`를 사용해서 만들어 모든 업데이트를 배치 작업으로 최적화할 수 있다

### 10.2.5 더욱 엄격해진 엄격 모드

- 엄격 모드: 리액트 애플리케이션에서 발생할 수도 있는 잠재적인 버그를 찾는 데 도움이 되는 컴포넌트
    - `<StrictMode>` 컴포넌트를 사용하면 엄격 모드를 활성화할 수 있다
    - 엄격 모드에서 수행하는 모드는 모두 개발자 모드에서만 작동하고 프로덕션 모드에서는 작동하지 않는다
- 엄격 모드에서 하는 작업
    - 더 이상 안전하지 않은 특정 생명주기를 사용하는 컴포넌트에 대한 경고
        - `componentWillMount`, `componentWillReceiveProps`, `componentWillUpdate`
    - 문자열 ref 사용 금지
        - 예전에는 컴포넌트 내부에서 문자열로 ref를 생성하고 DOM 노드를 참조하는 것이 가능했지만, 지금은 금지됨
    - findDOMNode에 대한 경고 출력
        - `findDOMNode`: 클래스 컴포넌트 인스턴스에서 실제 DOM 요소에 대한 참조를 가져오는 메서드
    - 구 Context API 사용 시 발생하는 경고
        - `childContextTypes`, `getChildContext`를 사용하는 경우 경고 출력
    - 예상치 못한 부작용(side-effects) 검사
        - 엄격 모드 내부에서는 다음 내용을 의도적으로 이중으로 호출한다
            - 클래스 컴포넌트의 `constructor`, `render`, `shouldComponentUpdate`, `getDerivedStateFromProps`
            - 클래스 컴포넌트의 `setState`의 첫번째 인수
            - 함수 컴포넌트의 `body`
            - `useState`, `useMemo`, `useReducer`에 전달되는 함수
        - 항상 순수한 결과물을 내고 있는지 확인하기 위해 두번 실행한다
        - state, props, context가 변경되지 않으면(입력 값이 변경되지 않으면) 항상 동일한 JSX(항상 값은 결과물)을 반환해야 한다
- 리액트 18 버전에 추가된 엄격 모드
    - 컴포넌트가 이펙트를 여러 번 마운트 및 제거해도 복원력이 있는지 검사
        - 고의로 `useEffect`를 두번 실행한다
        - 컴포넌트가 최초에 마운트될 때 자동으로 모든 컴포넌트를 마운트 해제하고 두번째 마운트에서 이전 상태를 복원한다

### 10.2.6 Suspense 기능 강화

- Suspense: 컴포넌트를 동적으로 가져올 수 있게 도와주는 기능
    - React.lazy: 컴포넌트를 첫 번째 렌더링 시에 불러오지 않고, 최초 렌더링 이후에 컴포넌트를 지연시켜 불러오는 역할
    - `Suspense`는 `lazy`를 통해 지연시켜 불러온 컴포넌트를 렌더링하는 역할을 한다
- 리액트 17 버전까지의 `Suspense`의 문제점
    - 기존의 `Suspense`는 컴포넌트가 아직 보이기도 전에 `useEffect`가 실행되는 문제가 존재했다
    - `Suspense`는 서버에서 사용할 수 없었다
- 리액트 18 버전부터는 `Suspense`를 정식으로 지원한다
    - 아직 마운트되기 직전임에도 effect가 빠르게 실행되는 문제가 수정되었다
    - `Suspense`로 인해 컴포넌트가 보이거나 사라질 때도 effect가 정상적으로 실행된다
    - `Suspense`를 서버에서도 실행할 수 있다
    - `Suspeense` 내에 스로틀링이 추가되었다

### 10.2.7 인터넷 익스플로러 지원 중단에 따른 추가 폴리필 필요

- 리액트는 리액트가 사용하는 코드에서 최신 자바스크립트 기능을 사용할 수 있다는 가정하에 배포된다
- 웹서비스가 여전히 인터넷 익스플로어 11을 지원해야 한다면 폴리필 설치 및 트랜스 파일에 신경써야 한다

### 10.2.8 그 밖에 알아두면 좋은 변경사항

- 컴포넌트에서 `undefined`를 반환해도 에러가 발생하지 않는다
- `<Suspense fallback={undefined}>`도 `null`가 동일하게 처리된다
- `renderToNodeStream` 지원이 중단되고 `renderToPipeableStream` 사용이 권장된다


