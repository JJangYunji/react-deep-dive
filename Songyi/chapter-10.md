# 10장: 리액트 17과 18의 변경 사항 살펴보기

- 리액트가 제공하는 최신 기능을 모두 활용하려면 리액트가 제공하는 새로운 버전을 조금씩 따라잡을 필요가 있다
- 리액트에 의존적인 라이브러리를 사용한다면 `peerDependencies`를 통해 리액트에 의존하고 있으므로 버전 업을 위해서는 이 라이브러리가 지원하는 버전에 대해 꼼꼼하게 살펴봐야 한다
    - 최소 리액트 지원 버전을 올렸는데, 사용 중인 서비스에서 아직 구형 버전의 리액트를 사용하고 있다면 낭패를 볼 수 있다

## 10.1 리액트 17 버전 살펴보기

### 10.1.1 리액트의 점진적인 업그레이드

- 리액트 17 버전은 16 버전과 다르게 새롭게 추가된 기능이 없으며 호환성이 깨지는 변경 사항, 즉 기존에 사용하던 코드의 수정을 필요로 하는 변경 사항을 최소화했다
- 기존에는 새로운 주 버전이 릴리스되면 이전 버전에서의 API 제공을 완전히 중단해 버리고, 전체 애플리케이션을 새롭게 업그레이드하기를 요구하고 있었다
    - 리액트 17 버전부터는 점진적인 업그레이드가 가능해진다
    - 전체 애플리케이션 트리는 리액트 17이지만 일부 트리와 컴포넌트에 대해서만 리액트 18을 선택하는 점진적인 버전 업이 가능해진다

### 10.1.2 이벤트 위임 방식의 변경

- 이벤트 단계
    - 캡처(capture): 이벤트 핸들러가 트리 최상단 요소에서 부터 시작해서 실제 이벤트가 발생한 타깃 요소까지 내려간다
    - 타깃(target): 이벤트 핸들러가 타깃 노드에 도달한다. 이때 이벤트가 호출된다
    - 버블링(bubbling): 이벤트가 발생한 요소에서부터 시작해 최상위 요소까지 다시 올라간다
- 이벤트 위임(event delegation)
    - 이벤트를 처리하는 방식 중 하나로, 이벤트를 처리할 때 이벤트를 발생시킨 요소에 직접 이벤트 핸들러를 등록하는 것이 아니라 상위 요소에 이벤트 핸들러를 등록하고, 이벤트가 발생한 요소를 찾아내는 방식
    - 하위 요소에서 발생한 이벤트를 상위 요소에 등록된 이벤트 핸들러를 통해 처리한다
    - 리액트는 이벤트 핸들러를 각 요소가 아닌 document에 연결해서 이벤트를 좀 더 효율적으로 관리한다
- 리액트 17 버전에서는 이벤트 위임 방식이 변경되었다
    - 리액트 16 버전까지는 이벤트 핸들러를 `document`에 연결해 이벤트를 관리했다
    - 리액트 17 버전부터는 이벤트 핸들러를 리액트 컴포넌트 최상단 트리, 즉 루트 요소로 변경되었다
        - 서로 다른 리액트 버전에서 발생할 수 있는 문제를 해결하기 위해 이벤트 위임의 대상을 `document`에서 컴포넌트의 최상위로 변경되었다
        - 각 이벤트는 해당 리액트 컴포넌트 트리 수준으로 격리되므로 이벤트 버블링으로 인한 혼선을 방지할 수 있다

### 10.1.3 import React from 'react'가 더이상 필요 없다: 새로운 transform

- JSX는 브라우저가 이해할 수 있는 코드가 아니므로 바벨이나 타입스크립트를 활용해 JSX를 실행하기 위해 일반적인 자바스크립트로 변환하는 과정이 꼭 필요하다
- 리액트 16 버전까지는 JSX 변환을 사용하기 위해 코드내에서 `React`를 사용하는 구문이 없더라도 `import React from 'react'`가 필요했고, 이 코드가 없으면 에러가 발생했다
- 리액트 17 버전부터는 바벨과 협력해 이러한 import 구문 없이도 JSX를 변환할 수 있게 되었다
    - `React.createElement`가 사라졌다
    - JSX를 변환할 때 필요한 모듈인 `react/jsx-runtime`을 불러오는 require 구문이 추가된다
    - `import React` 구문을 삭제함으로써 번들 크기를 줄일 수 있다

### 10.1.4 그 밖의 주요 변경 사항

#### 1) 이벤트 풀링 제거

- 이벤트 풀링
    - 이벤트 객체를 재사용하여 메모리 사용을 최소화하고 성능을 향상시키는 기법
    - `SyntheticEvent` 객체를 사용해 이벤트를 처리하고, 이벤트가 끝나면 해당 객체를 초기화해 재사용하는 방식
        - `SyntheticEvent` 이벤트: 브라우저의 기본 이벤트를 한 번 더 감싼 이벤트 객체
    - 풀에서 이벤트를 받아오고, 이벤트가 종료되자마자 다시 초기화하는(`null`로 변경하는) 방식
- 리액트 16 버전까지는 이벤트 풀링 방식을 통해 서로 다른 이벤트 간에 이벤트 객체를 재사용한다
    - 비동기 코드 내에서 이벤트 객체를 참조하면 이벤트 객체가 이미 초기화된 이후이기 때문에 버그가 발생할 수 있다
    - 비동기적으로 이벤트 객체를 사용하고자 할 때는 `e.persist()`를 호출해야 한다
- 리액트 17 버전부터는 이벤트 풀링 개념이 삭제된다
    - 이벤트 핸들러 내부에서 이벤트 객체에 접근할 때 비동기든 동기든 상관없이 일관적으로 동작한다

#### 2) useEffect 클린업 함수의 비동기 실행

- 클린업 함수: 컴포넌트가 언마운트되거나 업데이트되기 직전에 실행되는 함수
- 리액트 16 버전까지는 `useEffect` 훅의 클린업 함수가 동기적으로 실행되었다
- 리액트 17 버전부터는 화면이 완전히 업데이트된 이후에 클린업 함수가 비동기적으로 실행된다
    - 리렌더링이 일어난 뒤에 실행되어 화면에 업데이트가 반영되는 시간(commitTime)이 빨라진다

#### 3) 컴포넌트의 undefined 반환에 대한 일관적인 처리

- 리액트 16, 17 버전 모두 컴포넌트 내부에서 `undefind`를 반환하면 오류가 발생한다
- 리엑트 16 버전에서는 `forwardRef`나, `memo`와 같은 고차 컴포넌트를 사용할 때 `undefined`를 반환하면 오류가 발생하지 않는다
- 리액트 17 버전에서는 `undefined`를 반환하면 오류가 정상적으로 발생한다
- 리액트 18 버전부터는 `undefined`를 반환해도 오류가 발생하지 않는다

## 10.2 리액트 18 버전 살펴보기